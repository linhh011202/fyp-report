\section{Authentication Flows}
\label{sec:auth_flows}

This section describes the detailed authentication flows for each supported method.

\subsection{Email/Password Authentication}

The traditional login flow uses Passport's LocalStrategy for credential validation. Figure~\ref{fig:auth_login_flow} shows the sequence.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/auth_login_flow.png}
\caption{Email/Password Login Flow}
\label{fig:auth_login_flow}
\end{figure}

The login process:
\begin{enumerate}
    \item Client sends credentials to \texttt{POST /auth/login}.
    \item LocalAuthGuard triggers LocalStrategy validation.
    \item AuthService queries MongoDB and compares password hashes using bcrypt.
    \item If valid, existing tokens are revoked (single session enforcement).
    \item New JWT is generated and stored in UserTokens collection.
    \item Response includes access token, subscription end date, and verification status.
\end{enumerate}

\subsection{Google OAuth 2.0}

Google SSO uses Passport's OAuth 2.0 strategy with redirect-based authentication. This subsection covers the module architecture, authentication flow, and implementation details.

\subsubsection{Google SSO Module Structure}

Figure~\ref{fig:google_sso_module_structure} shows the architecture of the Google SSO module, including its integration with Passport and the shared Auth module.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/google_sso_module_structure.png}
\caption{Google SSO Module Architecture}
\label{fig:google_sso_module_structure}
\end{figure}

Key components include:
\begin{itemize}
    \item \textbf{GoogleSSOController}: Exposes \texttt{/auth/google/login} and \texttt{/auth/google/callback} endpoints.
    \item \textbf{GoogleAuthGuard}: Extends Passport's AuthGuard with custom state parameter handling.
    \item \textbf{GoogleStrategy}: Implements Passport strategy with OAuth 2.0 configuration.
    \item \textbf{AuthService}: Shared service for user verification and token management.
\end{itemize}

\subsubsection{Authentication Flow Overview}

Figure~\ref{fig:auth_google_flow} illustrates the high-level Google OAuth 2.0 flow.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/auth_google_flow.png}
\caption{Google OAuth 2.0 Flow}
\label{fig:auth_google_flow}
\end{figure}

\subsubsection{Complete User Flow}

Figure~\ref{fig:google_sso_user_flow} provides a comprehensive flowchart of the entire Google Sign-In process, from initial click to session establishment.

\begin{figure}[H]
\centering
\includegraphics[width=0.45\textwidth]{images/google_sso_user_flow.png}
\caption{Complete Google SSO User Journey}
\label{fig:google_sso_user_flow}
\end{figure}

The flow handles two scenarios:
\begin{itemize}
    \item \textbf{New Users}: After Google authentication, the \texttt{checkUserByEmail} method indicates a new user by returning a result where \texttt{requiresPassword} is \texttt{true}. A temporary token is generated and stored in localStorage, after which the user is redirected to the complete-signup page to set their password.
    \item \textbf{Existing Users}: All previous tokens are revoked, a new access token is generated and stored in UserTokens collection and localStorage, then the user is redirected to sign-in.
\end{itemize}

\subsubsection{Passport Authentication Flow}

Figure~\ref{fig:google_sso_oauth_flow} shows the detailed OAuth 2.0 authentication flow using Passport's Google strategy, including configuration and token exchange.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/google_sso_oauth_flow.png}
\caption{Google OAuth Passport Authentication Flow}
\label{fig:google_sso_oauth_flow}
\end{figure}

The authentication process involves:
\begin{enumerate}
    \item \textbf{Guard Initialization}: GoogleAuthGuard extracts query parameters and encodes them into a base64 state parameter.
    \item \textbf{Strategy Configuration}: GoogleStrategy configures OAuth client with credentials from AuthConfig.
    \item \textbf{Token Exchange}: After user consent, Google returns an authorization code which is exchanged for access tokens.
    \item \textbf{Profile Extraction}: The strategy validates and extracts user information (email, name, photo) from the profile.
\end{enumerate}

\subsubsection{State Parameter for Context Preservation}

A key feature of the Google SSO implementation is preserving query parameters through the OAuth redirect cycle using the state parameter. Figure~\ref{fig:google_sso_state_flow} illustrates this mechanism.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/google_sso_state_flow.png}
\caption{State Parameter Flow for Context Preservation}
\label{fig:google_sso_state_flow}
\end{figure}

The state parameter enables:
\begin{itemize}
    \item \textbf{Redirect URL Preservation}: Frontend callback URL is maintained across OAuth redirects.
    \item \textbf{Multi-tenant Support}: Application credentials (appId, appSecret) are preserved for token generation.
    \item \textbf{CSRF Protection}: The encoded state provides implicit protection against cross-site request forgery.
\end{itemize}

\subsubsection{Implementation Details}

\paragraph{Google Strategy Configuration.}
The GoogleStrategy extends Passport's base strategy with OAuth 2.0 configuration:

\begin{lstlisting}[language=TypeScript, caption={GoogleStrategy Implementation}]
@Injectable()
export class GoogleStrategy extends 
  PassportStrategy(Strategy, 'google') {
  constructor(@Inject(authConfig.KEY) private auth) {
    super({
      clientID: auth.googleClientId,
      clientSecret: auth.googleClientSecret,
      callbackURL: auth.googleCallbackURL,
      scope: ['email', 'profile'],
    });
  }

  async validate(req, accessToken, _refreshToken, 
    profile, done) {
    const user = {
      email: profile.emails[0].value,
      firstName: profile.name.givenName,
      lastName: profile.name.familyName,
    };
    done(null, user);
  }
}
\end{lstlisting}

\paragraph{Callback Handler Logic.}
The callback determines whether to redirect to complete-signup (new user) or sign-in (existing user):

\begin{lstlisting}[language=TypeScript, caption={Google Callback Handler}]
@Get('callback')
@UseGuards(GoogleAuthGuard)
async googleAuthRedirect(@Req() req, @Res() res) {
  const result = await this.authService.checkUserByEmail(
    req.user.email, userAgent, ipAddress
  );

  if (result.requiresPassword) {
    // New user - generate temporary token
    const tempToken = await this.authService
      .generateTemporaryToken(result.email);
    // Redirect to /complete-signup
  } else if (result.accessToken) {
    // Existing user - store token and redirect
  }
}
\end{lstlisting}

\subsection{Apple Sign-In}

Apple Sign-In uses a POST callback with the identity token, differing from Google's redirect-based OAuth flow. This subsection covers the module architecture, authentication flow, and implementation details.

\subsubsection{Apple SSO Module Structure}

Figure~\ref{fig:apple_sso_module_structure} shows the architecture of the Apple SSO module and its integration with the shared Auth module.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/apple_sso_module_structure.png}
\caption{Apple SSO Module Architecture}
\label{fig:apple_sso_module_structure}
\end{figure}

Key components include:
\begin{itemize}
    \item \textbf{AppleSSOController}: Handles the \texttt{POST} \texttt{/auth/apple/callback} endpoint.
    \item \textbf{apple-signin-auth library}: External dependency for token verification.
    \item \textbf{AuthService}: Shared service providing core functionality:
    \begin{itemize}
        \item \texttt{verifyAppleToken()}
        \item \texttt{checkUserByEmail()}
        \item \texttt{generateTemporaryToken()}
        \item \texttt{revokeAllUserTokens()}
    \end{itemize}
\end{itemize}

\subsubsection{Authentication Flow Overview}

Figure~\ref{fig:auth_apple_flow} shows the high-level Apple Sign-In flow.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/auth_apple_flow.png}
\caption{Apple Sign-In Flow}
\label{fig:auth_apple_flow}
\end{figure}

\subsubsection{Complete User Flow}

Figure~\ref{fig:apple_sso_user_flow} provides a comprehensive view of the entire Apple Sign-In process, from initial authentication to session establishment.

\begin{figure}[H]
\centering
\includegraphics[width=0.55\textwidth]{images/apple_sso_user_flow.png}
\caption{Complete Apple SSO User Journey}
\label{fig:apple_sso_user_flow}
\end{figure}

The flow branches based on whether the user exists:
\begin{itemize}
    \item \textbf{New Users}: Receive a temporary token and are redirected to complete signup, where they set a password before account creation.
    \item \textbf{Existing Users}: Have their previous tokens revoked (single session enforcement), receive a new access token stored in \texttt{UserTokens}, and are redirected with the token in localStorage.
\end{itemize}

\subsubsection{Token Verification Architecture}

The token verification process in Apple SSO is dual-layered. It primarily utilizes the \texttt{apple-signin-auth} library, but retains a manual fallback mechanism. Figure~\ref{fig:apple_sso_token_verification} illustrates this verification strategy.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/apple_sso_token_verification.png}
\caption{Apple SSO Token Verification Flow}
\label{fig:apple_sso_token_verification}
\end{figure}

The verification process:
\begin{enumerate}
    \item \textbf{Primary Path}: The controller uses the \texttt{apple-signin-auth} library to verify the id\_token. The library fetches Apple's JWKS, verifies the JWT signature, and checks token expiration.
    \item \textbf{Fallback Path}: If the primary verification fails, the controller falls back to the \texttt{verifyAppleToken()} method of the \texttt{AuthService}, which manually decodes and validates the token by checking the issuer, expiration, and audience against configured Apple Client IDs.
\end{enumerate}

\subsubsection{Implementation Details}

\begin{lstlisting}[language=TypeScript, caption={Apple Token Verification}]
@Post('callback')
async appleAuthCallback(@Body() body, @Res() res) {
  let appleResponse;
  try {
    // Primary: use apple-signin-auth library
    appleResponse = await appleSignin.verifyIdToken(
      body.id_token, 
      { audience: process.env.APPLE_CLIENT_ID }
    );
  } catch (error) {
    // Fallback: manual verification
    appleResponse = await this.authService
      .verifyAppleToken(body.id_token);
  }

  const result = await this.authService
    .checkUserByEmail(appleResponse.email);
  // Handle new user or existing user...
}
\end{lstlisting}

\subsection{Comparison of SSO Methods}

Table~\ref{tab:sso_comparison} compares the key differences between Google OAuth and Apple Sign-In implementations.

\begin{table}[H]
\centering
\begin{tabular}{|l|p{4.5cm}|p{4.5cm}|}
\hline
\textbf{Aspect} & \textbf{Google OAuth} & \textbf{Apple Sign-In} \\
\hline
Flow Type & OAuth 2.0 redirect & POST with id\_token \\
\hline
Guard & GoogleAuthGuard (Passport) & None (manual verification) \\
\hline
Verification & Passport strategy & apple-signin-auth library \\
\hline
Email Privacy & Direct email provided & May use relay email \\
\hline
State Management & Base64-encoded state parameter & Not applicable \\
\hline
\end{tabular}
\caption{Google vs Apple SSO Comparison}
\label{tab:sso_comparison}
\end{table}
