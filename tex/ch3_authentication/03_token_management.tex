\section{Token Management}
\label{sec:token_management}

This section covers the JWT token lifecycle, including the API endpoints for token operations and the Auth module architecture.

\subsection{Auth Module Architecture}

Figure~\ref{fig:auth_module_architecture} shows the architecture of the Auth module, including the relationships between controllers, guards, strategies, services, and storage.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/auth_module_architecture.png}
\caption{Auth Module Architecture}
\label{fig:auth_module_architecture}
\end{figure}

The module consists of:
\begin{itemize}
    \item \textbf{AuthController}: Exposes endpoints for login, logout, token verification, and token refresh.
    \item \textbf{Guards}: LocalAuthGuard for credential-based login, JwtAuthGuard for protected endpoints.
    \item \textbf{Strategies}: LocalStrategy validates email/password, JwtStrategy validates JWT tokens with dynamic key selection.
    \item \textbf{AuthService}: Core business logic for token operations.
    \item \textbf{Storage}: UserTokens tracks active sessions, TokenBlacklist stores revoked tokens.
\end{itemize}

\subsection{Token Lifecycle Overview}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{5.5cm}|}
\hline
\textbf{Stage} & \textbf{API Endpoint} & \textbf{Description} \\
\hline
Generation & POST /auth/login & Creates JWT on successful authentication \\
\hline
Verification & POST /auth/verify-token & Validates token against blacklist and expiry \\
\hline
Refresh & POST /auth/refresh-token & Issues new token, blacklists old one \\
\hline
Revocation & POST /auth/logout & Adds token to blacklist immediately \\
\hline
\end{tabular}
\caption{Token Lifecycle Stages}
\label{tab:token_lifecycle}
\end{table}

Figure~\ref{fig:token_lifecycle} illustrates the complete token lifecycle sequence.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/token_lifecycle.png}
\caption{Token Lifecycle Sequence}
\label{fig:token_lifecycle}
\end{figure}

\subsection{Token Generation}

Upon successful authentication, the AuthService generates a JWT containing user claims:

\begin{lstlisting}[language=TypeScript, caption={JWT Token Generation}]
async login(user, userAgent, ipAddress) {
  // Revoke existing tokens (single session)
  await this.revokeAllUserTokens(user._id.toString());

  const payload = {
    email: user.email,
    role: user.role,
    name: user.name,
    type: user.type,
  };
  
  const token = this.jwtService.sign(payload, {
    subject: user._id.toString()
  });
  const decoded = this.jwtService.decode(token);

  // Store active token
  await this.userTokenModel.create({
    userId: user._id.toString(),
    token,
    expiresAt: new Date(decoded.exp * 1000),
    userAgent,
    ipAddress,
  });

  return { accessToken: token, ... };
}
\end{lstlisting}

\subsection{Token Verification}

The verification process involves multiple validation steps. Figure~\ref{fig:token_verification_flow} shows the complete decision tree.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{images/token_verification_flow.png}
\caption{Token Verification Decision Flow}
\label{fig:token_verification_flow}
\end{figure}

The verification endpoint checks blacklist status, signature validity, and active session existence:

\begin{lstlisting}[language=TypeScript, caption={Token Verification}]
async verifyToken(token: string) {
  // 1. Check blacklist
  const isBlacklisted = await this.tokenBlacklistModel
    .findOne({ token });
  if (isBlacklisted) {
    throw new UnauthorizedException('Token revoked');
  }

  // 2. Verify signature and expiration
  const decoded = await this.jwtService.verifyAsync(token);

  // 3. Check active session
  const activeToken = await this.userTokenModel
    .findOne({ token });
  if (!activeToken) {
    throw new UnauthorizedException('Session expired');
  }

  return { user: decoded };
}
\end{lstlisting}

\subsection{JWT Validation with Dynamic Keys}

The JwtStrategy supports multi-tenant authentication with dynamic key selection. Figure~\ref{fig:jwt_validation_flow} shows this process.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/jwt_validation_flow.png}
\caption{JWT Validation with Dynamic Key Selection}
\label{fig:jwt_validation_flow}
\end{figure}

The strategy determines which public key to use based on the token's audience claim:
\begin{itemize}
    \item \textbf{Default tokens}: Use the platform's default public key.
    \item \textbf{Third-party app tokens}: Use the application's specific public key for verification.
\end{itemize}

\subsection{Token Refresh}

The token refresh process allows clients to obtain a new access token using an expired token, provided the signature is valid. Figure~\ref{fig:token_refresh_flow} illustrates this flow.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/token_refresh_flow.png}
\caption{Token Refresh Flow}
\label{fig:token_refresh_flow}
\end{figure}

Refresh enables session continuation with expired tokens (signature must still be valid):

\begin{lstlisting}[language=TypeScript, caption={Token Refresh}]
async refreshAccessToken(expiredToken: string) {
  // Decode without expiration check
  const decoded = this.jwtService.decode(expiredToken);
  
  // Verify signature only
  await this.jwtService.verifyAsync(expiredToken, { 
    ignoreExpiration: true 
  });
  
  // Blacklist old token
  await this.tokenBlacklistModel.create({
    token: expiredToken,
    userId: decoded.sub,
    expiresAt: new Date(decoded.exp * 1000),
    reason: 'refresh',
  });
  
  // Generate new token
  const newToken = this.jwtService.sign({...}, {
    subject: decoded.sub
  });
  
  return { accessToken: newToken };
}
\end{lstlisting}

\subsection{Token Revocation (Logout)}

The logout process involves removing the active session and blacklisting the current token. Figure~\ref{fig:token_revocation_flow} details this sequence.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/token_revocation_flow.png}
\caption{Token Revocation (Logout) Flow}
\label{fig:token_revocation_flow}
\end{figure}

\begin{lstlisting}[language=TypeScript, caption={Logout Implementation}]
async logout(token: string, userId: string) {
  const decoded = this.jwtService.decode(token);

  // Add to blacklist
  await this.tokenBlacklistModel.create({
    token,
    userId,
    expiresAt: new Date(decoded.exp * 1000),
    reason: 'logout',
  });

  // Remove from active tokens
  await this.userTokenModel.deleteOne({ token });
}
\end{lstlisting}
