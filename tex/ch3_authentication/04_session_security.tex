\section{Session Security}
\label{sec:session_security}

This section details the security mechanisms including database schemas, single session enforcement, and token blacklisting.

\subsection{Database Schema Design}

Two MongoDB collections support the session security system.

\subsubsection{UserTokens Collection}

Tracks all active sessions with metadata for auditing:

\begin{lstlisting}[language=TypeScript, caption={UserToken Schema}]
@Schema({ timestamps: true })
export class UserToken extends Document {
  @Prop({ required: true, index: true })
  userId: string;

  @Prop({ required: true })
  token: string;

  @Prop({ required: true, type: Date })
  expiresAt: Date;

  @Prop({ type: String })
  userAgent?: string;

  @Prop({ type: String })
  ipAddress?: string;
}

// TTL index - auto delete when expired
UserTokenSchema.index(
  { expiresAt: 1 }, 
  { expireAfterSeconds: 0 }
);
\end{lstlisting}

\subsubsection{TokenBlacklist Collection}

Stores revoked tokens to prevent reuse:

\begin{lstlisting}[language=TypeScript, caption={TokenBlacklist Schema}]
@Schema({ timestamps: true })
export class TokenBlacklist extends Document {
  @Prop({ required: true, index: true })
  token: string;

  @Prop({ required: true, index: true })
  userId: string;

  @Prop({ required: true, type: Date })
  expiresAt: Date;

  @Prop({ enum: ['logout', 'new-login', 'refresh'] })
  reason: string;
}

// TTL index for automatic cleanup
TokenBlacklistSchema.index(
  { expiresAt: 1 }, 
  { expireAfterSeconds: 0 }
);
\end{lstlisting}

\subsection{Single Session Enforcement}

When a user logs in, all existing sessions are invalidated:

\begin{lstlisting}[language=TypeScript, caption={Single Session Enforcement}]
async revokeAllUserTokens(userId: string) {
  // Find all active tokens
  const activeTokens = await this.userTokenModel.find({
    userId,
    expiresAt: { $gt: new Date() },
  });

  if (activeTokens.length === 0) return;

  // Bulk insert to blacklist
  const entries = activeTokens.map(t => ({
    token: t.token,
    userId: t.userId,
    expiresAt: t.expiresAt,
    reason: 'new-login',
  }));

  await this.tokenBlacklistModel.insertMany(entries);
  await this.userTokenModel.deleteMany({ userId });
}
\end{lstlisting}

Figure~\ref{fig:session_security} illustrates the session security flow.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{images/session_security.png}
\caption{Session Security Flow}
\label{fig:session_security}
\end{figure}

\subsection{Token Blacklisting Flow}

Figure~\ref{fig:token_blacklist_flow} shows how tokens are blacklisted under different scenarios.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{images/token_blacklist_flow.png}
\caption{Token Blacklisting Flow}
\label{fig:token_blacklist_flow}
\end{figure}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Reason} & \textbf{Trigger} & \textbf{Method} \\
\hline
logout & User logout & \texttt{logout()} \\
\hline
new-login & New login revokes old & \texttt{revokeAllUserTokens()} \\
\hline
refresh & Token refresh & \texttt{refreshAccessToken()} \\
\hline
\end{tabular}
\caption{Token Blacklist Reasons}
\label{tab:blacklist_reasons}
\end{table}

\subsection{Security Benefits}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{7cm}|}
\hline
\textbf{Feature} & \textbf{Benefit} \\
\hline
Single Session & Stolen tokens invalidated on new login \\
\hline
IP/UserAgent Tracking & Audit trail for security review \\
\hline
Token Blacklisting & Immediate revocation capability \\
\hline
TTL Auto-cleanup & MongoDB automatically removes expired entries \\
\hline
\end{tabular}
\caption{Security Features and Benefits}
\label{tab:security_benefits}
\end{table}
