\subsection{Payment \& Subscription Management}%
\label{sec:payment}

This subsection documents the payment processing and subscription management system built with Stripe integration, Redis caching, and MongoDB persistence.

\subsubsection{Architecture Overview}

Figure~\ref{fig:payment_architecture} illustrates the payment system architecture showing the interaction between modules.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/payment_architecture.png}
\caption{Payment System Architecture}
\label{fig:payment_architecture}
\end{figure}

The payment system consists of three main modules:

\begin{itemize}
    \item \textbf{StripeModule}: Handles Stripe API interactions, checkout sessions, webhooks
    \item \textbf{PlanModule}: Manages subscription plans with versioning and Redis caching
    \item \textbf{SubscriptionModule}: Tracks user subscriptions, quotas, and usage
\end{itemize}

\subsubsection{Plan Management}

Plans are stored as versioned JSON documents, cached in Redis for fast retrieval.

\noindent\textbf{Plan Schema}\\

\begin{lstlisting}[language=TypeScript, caption={Plan Schema Definition}]
@Schema({ timestamps: { createdAt: true, updatedAt: false } })
export class Plan extends Document {
  @Prop({ required: true, type: String, unique: true })
  id: string;

  @Prop({ required: true, type: String })
  plans: string; // JSON string of plan details

  @Prop({ required: true, type: Number, unique: true })
  version: number;

  createdAt?: Date;
}
\end{lstlisting}

\noindent\textbf{Plan Versioning}\\

Figure~\ref{fig:plan_versioning_flow} shows how plan versions are managed over time.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/plan_versioning_flow.png}
\caption{Plan Versioning Flow}
\label{fig:plan_versioning_flow}
\end{figure}

\noindent\textbf{Redis Caching with Cache Penetration Protection}\\

Figure~\ref{fig:plan_caching} illustrates the cache-aside pattern with NULL value caching.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{images/plan_caching.png}
\label{fig:plan_caching_ch4}
\end{figure}

\begin{lstlisting}[language=TypeScript, caption={Plan Caching Implementation}]
@Injectable()
export class PlanService implements OnModuleInit, OnModuleDestroy {
  private readonly CACHE_KEY = 'plan:latest';
  private readonly CACHE_TTL = 3600; // 1 hour
  private readonly NULL_TTL = 60; // 60 seconds

  async getLatestVersion(): Promise<Plan | null> {
    const cached = await this.redisClient.get(this.CACHE_KEY);
    if (cached) {
      if (cached === 'NULL') return null; // Cache penetration protection
      return JSON.parse(cached) as Plan;
    }

    const latestPlan = await this.planModel
      .findOne().sort({ version: -1 }).exec();

    if (latestPlan) {
      await this.redisClient.set(this.CACHE_KEY, JSON.stringify(latestPlan), {
        EX: this.CACHE_TTL,
      });
    } else {
      await this.redisClient.set(this.CACHE_KEY, 'NULL', {
        EX: this.NULL_TTL,
      });
    }
    return latestPlan;
  }
}
\end{lstlisting}

\subsubsection{Stripe Integration}

\noindent\textbf{Checkout Flow}\\

Figure~\ref{fig:stripe_checkout_flow} shows the complete Stripe Checkout flow from user request to subscription creation.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/stripe_checkout_flow.png}
\caption{Stripe Checkout Session Flow}
\label{fig:stripe_checkout_flow}
\end{figure}

\noindent\textbf{Checkout Session Creation}\\

\begin{lstlisting}[language=TypeScript, caption={Checkout Session Creation}]
@UseGuards(JwtAuthGuard)
@Post('stripe-checkout-session')
async createCheckoutSession(@Body() dto: CreateCheckoutSessionDto, @Req() req) {
  const userId = req.user?._id?.toString();
  const customerEmail = req.user?.email;

  const result = await this.stripeService.createCheckoutSession(
    dto.priceId,
    customerEmail,
    customerName,
    userId, // Stored in metadata for webhook
  );
  return result;
}
\end{lstlisting}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Endpoint} & \texttt{POST /stripe/stripe-checkout-session} \\
\hline
\textbf{Request} & \texttt{\{ "priceId": "price\_123..." \}} \\
\hline
\textbf{Response} & \texttt{\{ "url": "https://...", "sessionId": "cs\_test..." \}} \\
\hline
\end{tabular}
\caption{API: Create Checkout Session}
\end{table}


\subsubsection{Subscription Scheduling}

To support plan upgrades and downgrades without immediate billing impact, we implement a scheduling system using Stripe Subscription Schedules.

\noindent\textbf{Scheduling Flow}\\

Figure~\ref{fig:subscription_scheduling_flow} details the sequence for scheduling a plan change.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/subscription_scheduling_flow.png}
\caption{Subscription Plan Change Sequence}
\label{fig:subscription_scheduling_flow}
\end{figure}

The \texttt{StripeService.schedulePlanChange} method handles this logic:
\begin{enumerate}
    \item Retrieves current subscription details to identify the \texttt{current\_period\_end}.
    \item Checks for any existing subscription schedules to prevent conflicts or duplicates.
    \item If a schedule exists, it updates the subsequent phase with the new price.
    \item If no schedule exists, it creates a new one from the current subscription and appends a new phase for the plan change.
\end{enumerate}

\noindent\textbf{Advanced Scheduling Logic}\\

The implementation handles complex scenarios such as modifying an already scheduled change. As shown in Listing~\ref{lst:schedule_logic}, the system first checks for an `active` or `\texttt{not\_started}` schedule.

\begin{lstlisting}[language=TypeScript, caption={Smart Scheduling Logic in StripeService}, label={lst:schedule_logic}]
async schedulePlanChange(subscriptionId: string, newPriceId: string) {
  // 1. Get current subscription items
  const subscription = await this.stripe.subscriptions.retrieve(
    subscriptionId, { expand: ['items'] }
  );

  // 2. Check for existing schedules
  const schedules = await this.stripe.subscriptionSchedules.list({
    customer: subscription.customer as string,
  });
  const activeSchedule = schedules.data.find(s => 
    s.subscription === subscriptionId && 
    (s.status === 'active' || s.status === 'not_started')
  );

  if (activeSchedule) {
    // 3a. Update existing schedule: keep current phase, update next
    const currentPhase = activeSchedule.phases[0];
    return this.stripe.subscriptionSchedules.update(activeSchedule.id, {
      phases: [
        { ...currentPhase }, // Preserve current billing period
        { items: [{ price: newPriceId, quantity: 1 }] } // New plan starts next
      ]
    });
  }

  // 3b. Create new schedule from subscription
  const schedule = await this.stripe.subscriptionSchedules.create({
    from_subscription: subscriptionId,
  });
  
  // 4. Update the newly created schedule
  return this.stripe.subscriptionSchedules.update(schedule.id, {
    phases: [
      { ...schedule.phases[0] }, // Current phase
      { items: [{ price: newPriceId, quantity: 1 }] } // Next phase
    ]
  });
}
\end{lstlisting}

This approach ensures that user billing remains accurate. The user is not charged immediately; instead, the change takes effect exactly when the current billing cycle renews.

\noindent\textbf{Managing Scheduled Changes}\\

Users retain control over their scheduled changes. The system provides endpoints to retrieve schedule status and cancel pending changes if needed.

\begin{lstlisting}[language=TypeScript, caption={Controller endpoints for Schedule Management}]
@Post('get-schedule-info')
async getScheduleInfo(@Body() dto: GetScheduleInfoDto) {
  const schedule = await this.stripeService.getSubscriptionSchedule(
    dto.subscriptionId
  );
  if (!schedule) return { hasSchedule: false };
  
  const nextPhase = schedule.phases[1];
  return {
    hasSchedule: true,
    nextPriceId: nextPhase?.items[0]?.price,
    startDate: nextPhase?.start_date
  };
}

@Post('cancel-scheduled-change')
async cancelScheduledChange(@Body() dto: CancelScheduledChangeDto) {
  // Releases the schedule, reverting to standard subscription behavior
  return this.stripeService.cancelScheduledChange(dto.scheduleId);
}
\end{lstlisting}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Endpoint} & \texttt{POST /stripe/schedule-plan-change} \\
\hline
\textbf{Request} & \texttt{\{ "subscriptionId": "sub\_...", "newPriceId": "price\_..." \}} \\
\hline
\textbf{Response} & \texttt{\{ "scheduleId": "sub\_sched\_...", "status": "active" \}} \\
\hline
\end{tabular}
\caption{API: Schedule Plan Change}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Endpoint} & \texttt{POST /stripe/get-schedule-info} \\
\hline
\textbf{Request} & \texttt{\{ "subscriptionId": "sub\_..." \}} \\
\hline
\textbf{Response} & \texttt{\{ "hasSchedule": true, "nextPriceId": "price\_..." \}} \\
\hline
\end{tabular}
\caption{API: Get Schedule Info}
\end{table}

\subsubsection{Webhook Processing Logic}

Webhooks are central to maintaining synchronization between Stripe and our database.

\noindent\textbf{Webhook Flowchart}\\

Figure~\ref{fig:webhook_processing_logic} illustrates the decision logic for handling various Stripe events.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{images/webhook_processing_logic.png}
\caption{Stripe Webhook Processing Logic}
\label{fig:webhook_processing_logic}
\end{figure}

The \texttt{handleWebhook} method switches on \texttt{event.type}:
\begin{itemize}
    \item \texttt{checkout.session.completed}: Activates new subscriptions.
    \item \texttt{subscription\_schedule.updated}: Updates local DB with \texttt{scheduledPriceId} and \texttt{scheduledPlanId}.
    \item \texttt{subscription\_schedule.released}: Clears scheduled fields if the user cancels the pending change.
\end{itemize}

\begin{lstlisting}[language=TypeScript, caption={Stripe Webhook Handler}]
@Post('webhook')
async handleWebhook(@Headers('stripe-signature') signature, @Req() req) {
  const payload = req.body as Buffer;
  const event = await this.stripeService.handleWebhook(payload, signature);

  switch (event.type) {
    case 'checkout.session.completed':
      const session = event.data.object;
      const fullSession = await this.stripeService.getSessionWithLineItems(
        session.id
      );
      // ... Processing logic
      break;

    case 'subscription_schedule.updated':
      const schedule = event.data.object;
      const nextPhase = schedule.phases[1];
      if (nextPhase) {
         // Update subscription with scheduled plan details
         await this.subscriptionService.updateById(subId, {
           scheduledPriceId: nextPhase.items[0].price,
           // ...
         });
      }
      break;

    case 'subscription_schedule.released':
      // Clear scheduled fields
      break;
  }
  return { received: true };
}
\end{lstlisting}

\subsubsection{Subscription Management}

\noindent\textbf{Subscription Schema}\\


\begin{lstlisting}[language=TypeScript, caption={Subscription Schema (Key Fields)}]
export class Subscription extends Document {
  @Prop({ required: true, ref: User.name, type: ObjectId })
  user: string | User;

  @Prop({ type: String }) stripeSubscriptionId?: string;
  @Prop({ type: String }) stripeCustomerId?: string;
  @Prop({ type: String }) planName?: string;
  @Prop({ type: String }) priceId?: string;
  @Prop({ type: String }) planId?: string;

  // Scheduled change fields (for plan upgrades/downgrades)
  @Prop({ type: String }) scheduledPriceId?: string;
  @Prop({ type: String }) scheduledPlanId?: string;
  @Prop({ type: String }) scheduledPlanName?: string;
  @Prop({ type: String }) stripeScheduleId?: string;

  @Prop({ type: String, enum: ['active', 'canceled', ...], default: 'active' })
  status: string;

  @Prop(raw({ batchDuration: Number, liveDuration: Number }))
  quota: SubscriptionUnit;

  @Prop(raw({ batchDuration: Number, liveDuration: Number }))
  usage: SubscriptionUnit;

  @Prop({ type: Date }) startDate: Date;
  @Prop({ type: Date }) endDate: Date;
}
\end{lstlisting}

\noindent\textbf{Quota Checking}\\

Figure~\ref{fig:subscription_quota_check} illustrates the subscription and quota validation flow.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/subscription_quota_check.png}
\caption{Subscription Quota Checking Flow}
\label{fig:subscription_quota_check}
\end{figure}

\begin{lstlisting}[language=TypeScript, caption={Subscription Validation}]
async checkSubscription(userId: string, speechType?: 'live' | 'batch') {
  const sub = await this.subscriptionModel.findOne({ user: userId }).exec();

  if (!sub) return { success: false, message: 'User has no subscription' };

  if (speechType === 'batch' && sub.quota.batchDuration !== -1 &&
      sub.usage.batchDuration > sub.quota.batchDuration) {
    return { success: false, message: 'Batch quota exceeded' };
  }

  return { success: true, subscription: sub };
}
\end{lstlisting}

\subsubsection{Stripe Price Caching}

Figure~\ref{fig:stripe_price_caching} shows the price caching mechanism with cache penetration protection.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/stripe_price_caching.png}
\caption{Stripe Price Caching with Penetration Protection}
\label{fig:stripe_price_caching}
\end{figure}

\begin{lstlisting}[language=TypeScript, caption={Stripe Price Caching}]
async getPrice(priceId: string): Promise<Stripe.Price> {
  const cacheKey = `stripe:price:${priceId}`;
  const cached = await this.redisClient.get(cacheKey);

  if (cached) {
    if (cached === 'NULL') throw new Error('Price not found (cached)');
    return JSON.parse(cached) as Stripe.Price;
  }

  try {
    const price = await this.stripe.prices.retrieve(priceId);
    await this.redisClient.set(cacheKey, JSON.stringify(price), {
      EX: this.CACHE_TTL, // 24 hours
    });
    return price;
  } catch (error) {
    if (error?.code === 'resource_missing') {
      await this.redisClient.set(cacheKey, 'NULL', { EX: 60 });
    }
    throw error;
  }
}
\subsubsection{Subscription Lifecycle Management}

Beyond scheduling changes, the system provides full lifecycle management allowing users to cancel and resume their subscriptions.

\noindent\textbf{Cancellation and Resumption Flow}\\

Users can cancel their subscription, which sets the `cancel_at_period_end` flag in Stripe. This keeps the subscription active until the end of the billing cycle. If they change their mind, they can resume it before the cycle ends.

\begin{lstlisting}[language=TypeScript, caption={Subscription Cancellation and Resumption}]
@UseGuards(JwtAuthGuard)
@Post('cancel-subscription')
async cancelSubscription(@Body() dto: CancelSubscriptionDto, @Req() req) {
  // Calls Stripe to update subscription with cancel_at_period_end = true
  return this.stripeService.cancelSubscription(dto.subscriptionId);
}

@Post('resume-subscription')
async resumeSubscription(@Body() dto: ResumeSubscriptionDto) {
  // Reverts cancellation by setting cancel_at_period_end = false
  return this.stripeService.resumeSubscription(dto.subscriptionId);
}
\end{lstlisting}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Endpoint} & \texttt{POST /stripe/cancel-subscription} \\
\hline
\textbf{Request} & \texttt{\{ "subscriptionId": "sub\_..." \}} \\
\hline
\textbf{Response} & \texttt{\{ "status": "active", "cancelAtPeriodEnd": true \}} \\
\hline
\end{tabular}
\caption{API: Cancel Subscription}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Endpoint} & \texttt{POST /stripe/resume-subscription} \\
\hline
\textbf{Request} & \texttt{\{ "subscriptionId": "sub\_..." \}} \\
\hline
\textbf{Response} & \texttt{\{ "status": "active", "cancelAtPeriodEnd": false \}} \\
\hline
\end{tabular}
\caption{API: Resume Subscription}
\end{table}

\subsubsection{Administrative Operations}

To support operations, the system includes secured endpoints for administrators to manage plans and user subscriptions.

\noindent\textbf{Plan Management}\\

Administrators can publish new plan versions. The system automatically handles version incrementing and invalidates the Redis cache.

\begin{lstlisting}[language=TypeScript, caption={Admin Plan Creation}]
@Roles(Role.Admin)
@Post()
async create(@Body() dto: CreatePlansDto) {
  // Validates structure and creates new versioned plan document
  const result = await this.planService.create(dto.data);
  return result;
}
\end{lstlisting}

\noindent\textbf{User Subscription Administration}\\

Admins can manually intervene to update subscription quotas or extend validity periods for specific users.

\begin{lstlisting}[language=TypeScript, caption={Admin Subscription Update}]
@Roles(Role.Admin)
@Put('/user/:id')
async updateSubscriptionByUser(@Body() body: UpdateSubscriptionByUserDto, @Param() params) {
  // Manually update quota or end date
  return this.subscriptionService.updateByUser(params.id, {
    endDate: new Date(body.endDate),
    'quota.batchDuration': body.batchDuration,
    'quota.liveDuration': body.liveDuration,
  }, true);
}
\end{lstlisting}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Endpoint} & \texttt{POST /plans} (Admin) \\
\hline
\textbf{Request} & \texttt{\{ "data": "\{\textbackslash"plans\textbackslash": [...]\}" \}} \\
\hline
\textbf{Response} & \texttt{\{ "plans": "...", "version": 5 \}} \\
\hline
\end{tabular}
\caption{API: Create Plans}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Endpoint} & \texttt{PUT /subscriptions/user/:id} (Admin) \\
\hline
\textbf{Request} & \texttt{\{ "endDate": "2024-12-31", ... \}} \\
\hline
\textbf{Response} & \texttt{\{ "\_id": "...", "quota": \{...\}, "endDate": "..." \}} \\
\hline
\end{tabular}
\caption{API: Update User Subscription}
\end{table}

\subsubsection{Module Dependencies}

The Stripe module integrates with Subscription and Plan modules:
\begin{lstlisting}[language=TypeScript, caption={Stripe Module Configuration}]
@Module({
  imports: [
    StripeConfigurationModule,
    MongooseModule.forFeature([
      { name: Subscription.name, schema: SubscriptionSchema },
      { name: Plan.name, schema: PlanSchema },
    ]),
  ],
  controllers: [StripeController],
  providers: [StripeService, SubscriptionService, PlanService],
  exports: [StripeService],
})
export class StripeModule {}
\end{lstlisting}
