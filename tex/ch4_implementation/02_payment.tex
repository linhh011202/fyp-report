\subsection{Payment \& Subscription Management}%
\label{sec:payment}

This subsection documents the payment processing and subscription management system built with Stripe integration, Redis caching, and MongoDB persistence. The system is organized into three distinct backend modules that handle different aspects of the payment workflow.

\subsubsection{Architecture Overview}

Figure~\ref{fig:payment_architecture} illustrates the payment system architecture showing the interaction between modules.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/payment_architecture.png}
\caption{Payment System Architecture}
\label{fig:payment_architecture}
\end{figure}

The payment system consists of three main modules:

\begin{itemize}
    \item \textbf{Stripe Module}: Handles Stripe API interactions, checkout sessions, webhooks, and billing operations
    \item \textbf{Subscription Module}: Tracks user subscriptions, quotas, and usage
    \item \textbf{Plan Module}: Manages subscription plans with versioning and Redis caching
\end{itemize}

\paragraph{Subscription Lifecycle Events}

Figure~\ref{fig:subscription_lifecycle_events} illustrates the complete subscription lifecycle from initial purchase through renewal, cancellation, and expiration.

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{images/subscription_lifecycle_events.png}
\caption{Subscription Lifecycle State Diagram}
\label{fig:subscription_lifecycle_events}
\end{figure}

The subscription lifecycle consists of the following key events and their corresponding backend actions:

\begin{enumerate}
    \item \textbf{New Subscription (checkout.session.completed)}:
    \begin{itemize}
        \item Creates new subscription record in MongoDB
        \item Sets \texttt{startDate} to current timestamp
        \item Sets \texttt{endDate} to Stripe's \texttt{current\_period\_end}
        \item Assigns quota based on selected plan (\texttt{batchDuration}, \texttt{liveDuration})
        \item Initializes usage counters to 0
        \item Sets status to \texttt{active}
    \end{itemize}
    
    \item \textbf{Subscription Renewal (invoice.paid)}:
    \begin{itemize}
        \item Extends \texttt{endDate} by the billing period (e.g., +30 days for monthly)
        \item Resets \texttt{usage.batchDuration} and \texttt{usage.liveDuration} to 0
        \item Maintains existing quota allocation
        \item Updates status to \texttt{active} if previously past\_due
    \end{itemize}
    
    \item \textbf{Subscription Cancellation}:
    \begin{itemize}
        \item Sets \texttt{cancel\_at\_period\_end = true} in Stripe
        \item \texttt{endDate} remains unchanged (user retains access until period end)
        \item No immediate database status change
        \item User can resume subscription before \texttt{endDate}
    \end{itemize}
    
    \item \textbf{Subscription Expiration}:
    \begin{itemize}
        \item Triggered when current time exceeds \texttt{endDate}
        \item Sets status to \texttt{canceled}
        \item User loses access to premium features
        \item Quota checks return failure
    \end{itemize}
    
    \item \textbf{Plan Change Scheduling}:
    \begin{itemize}
        \item Stores \texttt{scheduledPriceId} and \texttt{scheduledPlanId}
        \item New plan takes effect at next billing cycle
        \item Quota updates when \texttt{subscription\_schedule.released} webhook fires
    \end{itemize}
\end{enumerate}

\paragraph{Post-Payment Database Updates}

When Stripe fires the \texttt{checkout.session.completed} webhook, the backend performs the following database operations:

\begin{lstlisting}[language=TypeScript, caption={Subscription Creation After Payment}]
async handleCheckoutCompleted(session: Stripe.Checkout.Session) {
  const subscription = await this.stripe.subscriptions.retrieve(
    session.subscription as string
  );
  
  // Get plan details from line items
  const planDetails = await this.getPlanFromPriceId(
    subscription.items.data[0].price.id
  );

  // Create or update subscription in MongoDB
  await this.subscriptionModel.findOneAndUpdate(
    { user: session.metadata.userId },
    {
      user: session.metadata.userId,
      stripeSubscriptionId: subscription.id,
      stripeCustomerId: session.customer as string,
      planId: planDetails.id,
      planName: planDetails.name,
      priceId: subscription.items.data[0].price.id,
      status: 'active',
      startDate: new Date(subscription.current_period_start * 1000),
      endDate: new Date(subscription.current_period_end * 1000),
      quota: {
        batchDuration: planDetails.batchDuration,
        liveDuration: planDetails.liveDuration,
      },
      usage: {
        batchDuration: 0,  // Reset usage on new subscription
        liveDuration: 0,
      },
    },
    { upsert: true, new: true }
  );
}
\end{lstlisting}

\paragraph{Renewal and Usage Reset}

When a subscription renews, the \texttt{invoice.paid} webhook triggers quota reset:

\begin{lstlisting}[language=TypeScript, caption={Subscription Renewal Handler}]
async handleInvoicePaid(invoice: Stripe.Invoice) {
  if (invoice.billing_reason !== 'subscription_cycle') return;

  const subscription = await this.stripe.subscriptions.retrieve(
    invoice.subscription as string
  );

  // Extend endDate and reset usage
  await this.subscriptionModel.findOneAndUpdate(
    { stripeSubscriptionId: subscription.id },
    {
      endDate: new Date(subscription.current_period_end * 1000),
      status: 'active',
      'usage.batchDuration': 0,  // Reset usage for new billing period
      'usage.liveDuration': 0,
    }
  );
}
\end{lstlisting}

\paragraph{Cancellation Expiry Handling}

When a user cancels, the subscription remains active until the billing period ends:

\begin{lstlisting}[language=TypeScript, caption={Cancellation with Period-End Expiry}]
async cancelSubscription(subscriptionId: string) {
  // Cancel at period end (not immediately)
  const subscription = await this.stripe.subscriptions.update(
    subscriptionId,
    { cancel_at_period_end: true }
  );

  // Update local record - endDate stays the same
  await this.subscriptionModel.findOneAndUpdate(
    { stripeSubscriptionId: subscriptionId },
    {
      // endDate remains unchanged - user keeps access until then
      cancelAtPeriodEnd: true,
      canceledAt: new Date(),
    }
  );

  return {
    status: subscription.status,
    cancelAt: subscription.cancel_at,
    endDate: new Date(subscription.current_period_end * 1000),
    message: 'Subscription will remain active until ' + 
             new Date(subscription.current_period_end * 1000).toISOString(),
  };
}
\end{lstlisting}

%% ============================================================================
%% PLAN MODULE
%% ============================================================================
\subsubsection{Stripe Module}
\label{sec:stripe_module}

The Stripe Module handles all payment-related operations including checkout sessions, subscription lifecycle management, plan scheduling, and webhook processing. It integrates with both the Plan and Subscription modules.

\paragraph{Module Structure}

The Stripe Module imports both Subscription and Plan schemas to manage cross-module operations. It configures the Stripe SDK through a dedicated configuration module and provides services for all payment-related functionality.

\begin{lstlisting}[language=TypeScript, caption={Stripe Module Configuration}]
@Module({
  imports: [
    StripeConfigurationModule,
    MongooseModule.forFeature([
      { name: Subscription.name, schema: SubscriptionSchema },
      { name: Plan.name, schema: PlanSchema },
    ]),
  ],
  controllers: [StripeController],
  providers: [StripeService, SubscriptionService, PlanService],
  exports: [StripeService],
})
export class StripeModule {}
\end{lstlisting}

\paragraph{Checkout Flow}

Figure~\ref{fig:stripe_checkout_flow} shows the complete Stripe Checkout flow from user request to subscription creation.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/stripe_checkout_flow.png}
\caption{Stripe Checkout Session Flow}
\label{fig:stripe_checkout_flow}
\end{figure}

\paragraph{API Endpoints}

Table~\ref{tab:stripe_endpoints} provides a complete list of Stripe module endpoints.

\begin{table}[H]
\centering
\caption{Stripe Module API Endpoints}
\label{tab:stripe_endpoints}
\begin{tabular}{|l|l|l|p{4.5cm}|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Auth} & \textbf{Description} \\
\hline
POST & /stripe/stripe-checkout-session & JWT & Create checkout session \\
\hline
POST & /stripe/check-subscription-status & JWT & Check subscription status \\
\hline
POST & /stripe/cancel-subscription & JWT & Cancel subscription \\
\hline
POST & /stripe/resume-subscription & JWT & Resume cancelled subscription \\
\hline
POST & /stripe/get-price & None & Get price information \\
\hline
POST & /stripe/schedule-plan-change & JWT & Schedule plan change \\
\hline
POST & /stripe/get-schedule-info & JWT & Get schedule info \\
\hline
POST & /stripe/cancel-scheduled-change & JWT & Cancel scheduled change \\
\hline
POST & /stripe/webhook & Stripe & Handle Stripe webhooks \\
\hline
\end{tabular}
\end{table}

\subparagraph{Create Checkout Session}

Creates a Stripe Checkout session for subscription purchase. User metadata is attached for webhook processing.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Create Checkout Session Request}]
POST /stripe/stripe-checkout-session
Authorization: Bearer <access-token>
Content-Type: application/json

{
  "priceId": "price_1234567890"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Create Checkout Session Response}]
{
  "url": "https://checkout.stripe.com/c/pay/cs_test_...",
  "sessionId": "cs_test_a1b2c3d4e5f6"
}
\end{lstlisting}

\subparagraph{Check Subscription Status}

Retrieves detailed subscription status including cancellation information.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Check Subscription Status Request}]
POST /stripe/check-subscription-status
Authorization: Bearer <access-token>
Content-Type: application/json

{
  "subscriptionId": "sub_1234567890"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Check Subscription Status Response}]
{
  "subscriptionId": "sub_1234567890",
  "status": "active",
  "isCancelled": false,
  "canceledAt": null,
  "cancelAtPeriodEnd": false,
  "currentPeriodEnd": 1704067199
}
\end{lstlisting}

\subparagraph{Cancel Subscription}

Cancels a subscription at the end of the current billing period.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Cancel Subscription Request}]
POST /stripe/cancel-subscription
Authorization: Bearer <access-token>
Content-Type: application/json

{
  "subscriptionId": "sub_1234567890"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Cancel Subscription Response}]
{
  "subscriptionId": "sub_1234567890",
  "status": "active",
  "cancelAt": 1704067199,
  "cancelAtPeriodEnd": true,
  "message": "Subscription will be cancelled at the end of the current billing period"
}
\end{lstlisting}

\subparagraph{Resume Subscription}

Reverts a pending cancellation, keeping the subscription active.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Resume Subscription Request}]
POST /stripe/resume-subscription
Authorization: Bearer <access-token>
Content-Type: application/json

{
  "subscriptionId": "sub_1234567890"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Resume Subscription Response}]
{
  "subscriptionId": "sub_1234567890",
  "status": "active",
  "cancelAt": null,
  "cancelAtPeriodEnd": false
}
\end{lstlisting}

\subparagraph{Get Price Information}

Retrieves Stripe price details with Redis caching.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Get Price Request}]
POST /stripe/get-price
Content-Type: application/json

{
  "price_id": "price_1234567890"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Get Price Response}]
{
  "id": "price_1234567890",
  "currency": "usd",
  "unit_amount": 1999,
  "recurring": {
    "interval": "month",
    "interval_count": 1
  }
}
\end{lstlisting}

\paragraph{Subscription Scheduling}

To support plan upgrades and downgrades without immediate billing impact, the system implements a scheduling mechanism using Stripe Subscription Schedules.

\subparagraph{Scheduling Flow}

Figure~\ref{fig:subscription_scheduling_flow} details the sequence for scheduling a plan change.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/subscription_scheduling_flow.png}
\caption{Subscription Plan Change Scheduling Sequence}
\label{fig:subscription_scheduling_flow}
\end{figure}

The scheduling process follows these steps:
\begin{enumerate}
    \item Retrieves current subscription details to identify the \texttt{current\_period\_end}.
    \item Checks for any existing subscription schedules to prevent conflicts.
    \item If a schedule exists, updates the subsequent phase with the new price.
    \item If no schedule exists, creates a new one from the current subscription.
\end{enumerate}

\subparagraph{Advanced Scheduling Logic}

The implementation handles complex scenarios such as modifying an already scheduled change:

\begin{lstlisting}[language=TypeScript, caption={Smart Scheduling Logic in StripeService}, label={lst:schedule_logic}]
async schedulePlanChange(subscriptionId: string, newPriceId: string) {
  // 1. Get current subscription
  const subscription = await this.stripe.subscriptions.retrieve(
    subscriptionId, { expand: ['items'] }
  );

  // 2. Check for existing schedules
  const schedules = await this.stripe.subscriptionSchedules.list({
    customer: subscription.customer as string,
  });
  const activeSchedule = schedules.data.find(s => 
    s.subscription === subscriptionId && 
    (s.status === 'active' || s.status === 'not_started')
  );

  if (activeSchedule) {
    // 3a. Update existing schedule
    const currentPhase = activeSchedule.phases[0];
    return this.stripe.subscriptionSchedules.update(activeSchedule.id, {
      phases: [
        { ...currentPhase },
        { items: [{ price: newPriceId, quantity: 1 }] }
      ]
    });
  }

  // 3b. Create new schedule from subscription
  const schedule = await this.stripe.subscriptionSchedules.create({
    from_subscription: subscriptionId,
  });
  
  return this.stripe.subscriptionSchedules.update(schedule.id, {
    phases: [
      { ...schedule.phases[0] },
      { items: [{ price: newPriceId, quantity: 1 }] }
    ]
  });
}
\end{lstlisting}

\subparagraph{Schedule Plan Change}

Schedules a plan change to take effect at the next billing period.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Schedule Plan Change Request}]
POST /stripe/schedule-plan-change
Authorization: Bearer <access-token>
Content-Type: application/json

{
  "subscriptionId": "sub_1234567890",
  "newPriceId": "price_pro_monthly"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Schedule Plan Change Response}]
{
  "scheduleId": "sub_sched_abc123",
  "subscriptionId": "sub_1234567890",
  "status": "active",
  "currentPhaseEnd": 1704067199,
  "nextPriceId": "price_pro_monthly",
  "message": "Plan change scheduled for next billing period"
}
\end{lstlisting}

\subparagraph{Get Schedule Info}

Retrieves information about a pending scheduled plan change.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Get Schedule Info Request}]
POST /stripe/get-schedule-info
Authorization: Bearer <access-token>
Content-Type: application/json

{
  "subscriptionId": "sub_1234567890"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Get Schedule Info Response}]
{
  "hasSchedule": true,
  "scheduleId": "sub_sched_abc123",
  "status": "active",
  "currentPhaseEnd": 1704067199,
  "nextPriceId": "price_pro_monthly"
}
\end{lstlisting}

\subparagraph{Cancel Scheduled Change}

Cancels a pending scheduled plan change.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Cancel Scheduled Change Request}]
POST /stripe/cancel-scheduled-change
Authorization: Bearer <access-token>
Content-Type: application/json

{
  "scheduleId": "sub_sched_abc123"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Cancel Scheduled Change Response}]
{
  "scheduleId": "sub_sched_abc123",
  "status": "released",
  "message": "Scheduled plan change cancelled successfully"
}
\end{lstlisting}

\paragraph{Webhook Processing}

Webhooks are central to maintaining synchronization between Stripe and the local database.

\subparagraph{Webhook Flowchart}

Figure~\ref{fig:webhook_processing_logic} illustrates the decision logic for handling various Stripe events.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{images/webhook_processing_logic.png}
\caption{Stripe Webhook Processing Logic}
\label{fig:webhook_processing_logic}
\end{figure}

The webhook handler processes the following event types:
\begin{itemize}
    \item \texttt{checkout.session.completed}: Activates new subscriptions
    \item \texttt{subscription\_schedule.updated}: Updates local DB with scheduled plan details
    \item \texttt{subscription\_schedule.released}: Clears scheduled fields when changes are cancelled
\end{itemize}

\subparagraph{Webhook Endpoint}

Receives and processes Stripe webhook events.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Stripe Webhook Request}]
POST /stripe/webhook
stripe-signature: t=1234567890,v1=abc123...
Content-Type: application/json

{
  "id": "evt_1234567890",
  "type": "checkout.session.completed",
  "data": {
    "object": {
      "id": "cs_test_abc123",
      "customer": "cus_abc123",
      "subscription": "sub_abc123"
    }
  }
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Stripe Webhook Response}]
{
  "received": true
}
\end{lstlisting}

\subparagraph{Webhook Handler Implementation}

The webhook handler implementation processes different event types:

\begin{lstlisting}[language=TypeScript, caption={Stripe Webhook Handler}]
@Post('webhook')
async handleWebhook(
  @Headers('stripe-signature') signature: string, 
  @Req() req: Request
) {
  const payload = req.body as Buffer;
  const event = await this.stripeService.handleWebhook(payload, signature);

  switch (event.type) {
    case 'checkout.session.completed':
      const session = event.data.object;
      const fullSession = await this.stripeService.getSessionWithLineItems(
        session.id
      );
      // Create subscription record with plan details
      break;

    case 'subscription_schedule.updated':
      const schedule = event.data.object;
      const nextPhase = schedule.phases[1];
      if (nextPhase) {
        await this.subscriptionService.updateById(subId, {
          scheduledPriceId: nextPhase.items[0].price,
          scheduledPlanId: nextPhase.plan,
        });
      }
      break;

    case 'subscription_schedule.released':
      // Clear scheduled fields
      await this.subscriptionService.updateById(subscription._id, {
        scheduledPriceId: null,
        scheduledPlanId: null,
        stripeScheduleId: null,
      });
      break;
  }
  return { received: true };
}
\end{lstlisting}

\paragraph{Price Caching}

Figure~\ref{fig:stripe_price_caching} shows the price caching mechanism with cache penetration protection.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/stripe_price_caching.png}
\caption{Stripe Price Caching with Penetration Protection}
\label{fig:stripe_price_caching}
\end{figure}

\begin{lstlisting}[language=TypeScript, caption={Stripe Price Caching Implementation}]
async getPrice(priceId: string): Promise<Stripe.Price> {
  const cacheKey = `stripe:price:${priceId}`;
  const cached = await this.redisClient.get(cacheKey);

  if (cached) {
    if (cached === 'NULL') throw new Error('Price not found (cached)');
    return JSON.parse(cached) as Stripe.Price;
  }

  try {
    const price = await this.stripe.prices.retrieve(priceId);
    await this.redisClient.set(cacheKey, JSON.stringify(price), {
      EX: 86400, // 24 hours
    });
    return price;
  } catch (error) {
    if (error?.code === 'resource_missing') {
      await this.redisClient.set(cacheKey, 'NULL', { EX: 60 });
    }
    throw error;
  }
}
\end{lstlisting}\subsubsection{Subscription Module}
\label{sec:subscription_module}

The Subscription Module tracks user subscriptions, manages quotas, monitors usage, and handles scheduled plan changes. It serves as the central source of truth for user subscription state.

\paragraph{Module Structure}

The Subscription Module follows a similar architecture pattern, providing dedicated endpoints for subscription management and exporting the service for use by other modules.

\begin{lstlisting}[language=TypeScript, caption={Subscription Module Structure}]
@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Subscription.name, schema: SubscriptionSchema },
    ]),
  ],
  controllers: [SubscriptionController],
  providers: [SubscriptionService],
  exports: [SubscriptionService],
})
export class SubscriptionModule {}
\end{lstlisting}

\paragraph{Data Model}

The Subscription schema captures comprehensive subscription state including Stripe integration fields, quota management, usage tracking, and scheduled plan changes. The schema uses MongoDB's embedded document pattern for quota and usage objects.

\begin{lstlisting}[language=TypeScript, caption={Subscription Schema}]
@Schema({ timestamps: true })
export class Subscription extends Document {
  @Prop({ required: true, ref: User.name, type: ObjectId })
  user: string | User;

  // Stripe integration fields
  @Prop({ type: String }) stripeSubscriptionId?: string;
  @Prop({ type: String }) stripeCustomerId?: string;
  @Prop({ type: String }) planName?: string;
  @Prop({ type: String }) priceId?: string;
  @Prop({ type: String }) planId?: string;

  // Scheduled change fields (for plan upgrades/downgrades)
  @Prop({ type: String }) scheduledPriceId?: string;
  @Prop({ type: String }) scheduledPlanId?: string;
  @Prop({ type: String }) scheduledPlanName?: string;
  @Prop({ type: String }) stripeScheduleId?: string;

  // Subscription status
  @Prop({ 
    type: String, 
    enum: ['active', 'canceled', 'incomplete', 'incomplete_expired', 
           'past_due', 'trialing', 'unpaid', 'paused'],
    default: 'active' 
  })
  status: string;

  // Quota and usage tracking
  @Prop(raw({ batchDuration: Number, liveDuration: Number }))
  quota: SubscriptionUnit;

  @Prop(raw({ batchDuration: Number, liveDuration: Number }))
  usage: SubscriptionUnit;

  // Validity period
  @Prop({ type: Date }) startDate: Date;
  @Prop({ type: Date }) endDate: Date;
}
\end{lstlisting}

\paragraph{Quota Checking}

Figure~\ref{fig:subscription_quota_check} illustrates the subscription and quota validation flow used before processing requests.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/subscription_quota_check.png}
\caption{Subscription Quota Checking Flow}
\label{fig:subscription_quota_check}
\end{figure}

The quota checking logic validates user subscriptions and usage limits:

\begin{lstlisting}[language=TypeScript, caption={Subscription Quota Validation}]
async checkSubscription(userId: string, speechType?: 'live' | 'batch') {
  const sub = await this.subscriptionModel.findOne({ user: userId }).exec();

  if (!sub) {
    return { success: false, message: 'User has no subscription' };
  }

  // Check batch quota (-1 means unlimited)
  if (speechType === 'batch' && sub.quota.batchDuration !== -1 &&
      sub.usage.batchDuration > sub.quota.batchDuration) {
    return { success: false, message: 'Batch quota exceeded' };
  }

  // Check live quota
  if (speechType === 'live' && sub.quota.liveDuration !== -1 &&
      sub.usage.liveDuration > sub.quota.liveDuration) {
    return { success: false, message: 'Live quota exceeded' };
  }

  return { success: true, subscription: sub };
}
\end{lstlisting}

\paragraph{API Endpoints}

Table~\ref{tab:subscription_endpoints} provides a complete list of Subscription module endpoints.

\begin{table}[H]
\centering
\caption{Subscription Module API Endpoints}
\label{tab:subscription_endpoints}
\begin{tabular}{|l|l|l|p{5cm}|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Auth} & \textbf{Description} \\
\hline
GET & /subscriptions/user/:id & Admin & Get user subscription \\
\hline
PUT & /subscriptions/user/:id & Admin & Update user subscription \\
\hline
\end{tabular}
\end{table}

\subparagraph{Get User Subscription (Admin)}

Retrieves subscription details for a specific user.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Get User Subscription Request}]
GET /subscriptions/user/6507a1b2c3d4e5f6a7b8c9d0
Authorization: Bearer <admin-token>
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Get User Subscription Response}]
{
  "_id": "sub_123456",
  "user": "6507a1b2c3d4e5f6a7b8c9d0",
  "status": "active",
  "planName": "Pro",
  "quota": {
    "batchDuration": 3600,
    "liveDuration": 1800
  },
  "usage": {
    "batchDuration": 1200,
    "liveDuration": 600
  },
  "startDate": "2024-01-01T00:00:00Z",
  "endDate": "2024-12-31T23:59:59Z"
}
\end{lstlisting}

\subparagraph{Update User Subscription (Admin)}

Allows administrators to manually update subscription quotas or extend validity periods.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Update User Subscription Request}]
PUT /subscriptions/user/6507a1b2c3d4e5f6a7b8c9d0
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "endDate": "2025-12-31",
  "batchDuration": 7200,
  "liveDuration": 3600
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Update User Subscription Response}]
{
  "_id": "sub_123456",
  "user": "6507a1b2c3d4e5f6a7b8c9d0",
  "quota": {
    "batchDuration": 7200,
    "liveDuration": 3600
  },
  "endDate": "2025-12-31T23:59:59Z"
}
\end{lstlisting}

%% ============================================================================
%% STRIPE MODULE
%% ============================================================================
\subsubsection{Plan Module}
\label{sec:plan_module}

The Plan Module manages subscription plan definitions with versioning support and high-performance Redis caching. Plans are stored as versioned JSON documents, allowing for plan updates without affecting existing subscribers.

\paragraph{Module Structure}

The Plan Module follows the standard NestJS module architecture with a controller for handling HTTP requests, a service for business logic, and MongoDB integration via Mongoose.

\begin{lstlisting}[language=TypeScript, caption={Plan Module Structure}]
@Module({
  imports: [
    MongooseModule.forFeature([{ name: Plan.name, schema: PlanSchema }]),
  ],
  controllers: [PlanController],
  providers: [PlanService],
  exports: [PlanService],
})
export class PlanModule {}
\end{lstlisting}

\paragraph{Data Model}

Plans are stored with automatic versioning to support historical tracking and rollback capabilities. Each plan document contains a unique identifier, a JSON string with plan details, and an auto-incrementing version number.

\begin{lstlisting}[language=TypeScript, caption={Plan Schema Definition}]
@Schema({ timestamps: { createdAt: true, updatedAt: false } })
export class Plan extends Document {
  @Prop({ required: true, type: String, unique: true })
  id: string;

  @Prop({ required: true, type: String })
  plans: string; // JSON string containing plan details

  @Prop({ required: true, type: Number, unique: true })
  version: number;

  createdAt?: Date;
}
\end{lstlisting}

\paragraph{Plan JSON Format}

The \texttt{plans} field stores a stringified JSON object with the following structure:

\begin{lstlisting}[language=TypeScript, caption={Plan JSON Structure}]
{
  "plans": [
    {
      "id": string,           // Unique plan identifier
      "name": string,         // Display name
      "priceId": string,      // Stripe price ID
      "features": string[],   // List of feature descriptions
      "recommended": boolean, // Optional: highlight flag
      "batchDuration": number,// Quota in seconds (-1 for unlimited)
      "liveDuration": number  // Quota in seconds (-1 for unlimited)
    }
  ]
}
\end{lstlisting}

\paragraph{Plan JSON Example}

A typical plan configuration includes Free, Basic, and Pro tiers:

\begin{lstlisting}[language=TypeScript, caption={Plan JSON Example}]
{
  "plans": [
    {
      "id": "basic",
      "name": "Basic",
      "priceId": "price_1NqKx2LkdIwHu7ixsKR4L2nS",
      "features": [
        "60 minutes batch processing per month",
        "30 minutes live transcription per month",
        "Priority support",
        "High quality audio processing"
      ],
      "recommended": false,
      "batchDuration": 3600,
      "liveDuration": 1800
    },
    {
      "id": "pro",
      "name": "Pro",
      "priceId": "price_1NqKxBLkdIwHu7ixCkcQHZgD",
      "features": [
        "Unlimited batch processing",
        "Unlimited live transcription",
        "24/7 Premium support",
        "Highest quality audio processing",
        "Custom integrations"
      ],
      "recommended": true,
      "batchDuration": -1,
      "liveDuration": -1
    }
  ]
}
\end{lstlisting}

\paragraph{Plan Versioning}

Figure~\ref{fig:plan_versioning_flow} shows how plan versions are managed over time, enabling seamless plan updates.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/plan_versioning_flow.png}
\caption{Plan Versioning Flow}
\label{fig:plan_versioning_flow}
\end{figure}

\paragraph{Redis Caching with Cache Penetration Protection}

The service implements a cache-aside pattern with NULL value caching to prevent cache penetration attacks. Figure~\ref{fig:plan_caching} illustrates this caching strategy.

\begin{figure}[H]
\centering
\includegraphics[width=0.65\textwidth]{images/plan_caching.png}
\caption{Plan Caching with Penetration Protection}
\label{fig:plan_caching_ch4}
\end{figure}

\begin{lstlisting}[language=TypeScript, caption={Plan Caching Implementation}]
@Injectable()
export class PlanService implements OnModuleInit, OnModuleDestroy {
  private readonly CACHE_KEY = 'plan:latest';
  private readonly CACHE_TTL = 3600; // 1 hour
  private readonly NULL_TTL = 60; // 60 seconds for null cache

  async getLatestVersion(): Promise<Plan | null> {
    // Check cache first
    const cached = await this.redisClient.get(this.CACHE_KEY);
    if (cached) {
      if (cached === 'NULL') return null; // Cache penetration protection
      return JSON.parse(cached) as Plan;
    }

    // Query database
    const latestPlan = await this.planModel
      .findOne().sort({ version: -1 }).exec();

    // Cache result (including null to prevent penetration)
    if (latestPlan) {
      await this.redisClient.set(this.CACHE_KEY, JSON.stringify(latestPlan), {
        EX: this.CACHE_TTL,
      });
    } else {
      await this.redisClient.set(this.CACHE_KEY, 'NULL', {
        EX: this.NULL_TTL,
      });
    }
    return latestPlan;
  }
}
\end{lstlisting}

\paragraph{API Endpoints}

Table~\ref{tab:plan_endpoints} provides a complete list of Plan module endpoints.

\begin{table}[H]
\centering
\caption{Plan Module API Endpoints}
\label{tab:plan_endpoints}
\begin{tabular}{|l|l|l|p{5cm}|}
\hline
\textbf{Method} & \textbf{Endpoint} & \textbf{Auth} & \textbf{Description} \\
\hline
GET & /plans/latest & None & Get latest plan version \\
\hline
POST & /plans & Admin & Create new plan version \\
\hline
\end{tabular}
\end{table}

\subparagraph{Get Latest Plans}

Retrieves the most recent version of subscription plans. This endpoint is publicly accessible.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Get Latest Plans Request}]
GET /plans/latest
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Get Latest Plans Response}]
{
  "id": "plan_abc123",
  "plans": "{\"free\": {...}, \"pro\": {...}}",
  "version": 3,
  "createdAt": "2024-01-15T10:30:00Z"
}
\end{lstlisting}

\subparagraph{Create Plans (Admin)}

Creates a new plan version. Requires admin privileges. The system automatically increments the version number and invalidates the Redis cache.

\noindent\textbf{Request:}
\begin{lstlisting}[language=TypeScript, caption={Create Plans Request}]
POST /plans
Authorization: Bearer <admin-token>
Content-Type: application/json

{
  "data": "{\"plans\": [{\"name\": \"Free\", ...}, {\"name\": \"Pro\", ...}]}"
}
\end{lstlisting}

\noindent\textbf{Response:}
\begin{lstlisting}[language=TypeScript, caption={Create Plans Response}]
{
  "id": "plan_def456",
  "plans": "{...}",
  "version": 4,
  "createdAt": "2024-01-20T14:00:00Z"
}
\end{lstlisting}

%% ============================================================================
%% SUBSCRIPTION MODULE
%% ============================================================================
