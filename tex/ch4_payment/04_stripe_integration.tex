\section{Stripe Integration}
\label{sec:stripe_integration}

The Stripe module handles payment processing through Stripe's API, including checkout session creation, webhook handling, and subscription lifecycle management.

\subsection{Module Architecture}

The Stripe module integrates with both Plan and Subscription modules:
\begin{itemize}
    \item \textbf{StripeController}: Exposes payment endpoints and receives webhooks.
    \item \textbf{StripeService}: Wraps Stripe SDK with caching layer.
    \item \textbf{PlanService}: Provides plan data for webhook processing.
    \item \textbf{SubscriptionService}: Creates subscriptions from successful payments.
\end{itemize}

\subsection{Checkout Session Flow}

Figure~\ref{fig:stripe_checkout_flow} illustrates the complete checkout process from plan selection to subscription creation.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/stripe_checkout_flow.png}
\caption{Stripe Checkout Session Flow}
\label{fig:stripe_checkout_flow}
\end{figure}

The checkout flow involves three parties:
\begin{enumerate}
    \item \textbf{Frontend}: Initiates checkout and handles redirects.
    \item \textbf{API Gateway}: Creates sessions and processes webhooks.
    \item \textbf{Stripe}: Hosts the secure checkout page and sends events.
\end{enumerate}

\subsection{Implementation Details}

\subsubsection{Creating Checkout Sessions}

\begin{lstlisting}[language=TypeScript, caption={Checkout Session Creation}]
async createCheckoutSession(
  priceId: string,
  customerEmail?: string,
  userId?: string,
): Promise<{ url: string; sessionId: string }> {
  const sessionParams: Stripe.Checkout.SessionCreateParams = {
    payment_method_types: ['card'],
    mode: 'subscription',
    line_items: [{ price: priceId, quantity: 1 }],
    success_url: this.configService.get('stripe.successUrl'),
    cancel_url: this.configService.get('stripe.cancelUrl'),
    billing_address_collection: 'required',
  }

  if (customerEmail) {
    sessionParams.customer_email = customerEmail
  }
  
  // Store userId for webhook processing
  if (userId) {
    sessionParams.metadata = { userId }
  }

  const session = await this.stripe.checkout.sessions.create(
    sessionParams
  )
  return { url: session.url, sessionId: session.id }
}
\end{lstlisting}

Key configuration parameters:
\begin{itemize}
    \item \texttt{mode: 'subscription'}: Enables recurring billing.
    \item \texttt{metadata.userId}: Links the payment to the user's account.
    \item \texttt{success\_url / cancel\_url}: Redirect destinations after checkout.
\end{itemize}

\subsubsection{Webhook Handler}

\begin{lstlisting}[language=TypeScript, caption={Webhook Processing}]
@Post('webhook')
async handleWebhook(
  @Headers('stripe-signature') signature: string,
  @Req() req: Request,
) {
  const payload = req.body as Buffer
  const event = await this.stripeService.handleWebhook(
    payload, signature
  )

  switch (event.type) {
    case 'checkout.session.completed':
      const session = event.data.object
      const fullSession = await this.stripeService
        .getSessionWithLineItems(session.id)
      
      const priceId = fullSession.line_items?.data?.[0]
        ?.price?.id
      const userId = fullSession.metadata?.userId
      
      // Match plan and create subscription
      const latestPlans = await this.planService
        .getLatestVersion()
      const plansData = JSON.parse(latestPlans.plans)
      const matchingPlan = plansData.plans
        .find(p => p.priceId === priceId)
      
      await this.createOrUpdateSubscription(
        userId, matchingPlan, fullSession
      )
      break
  }

  return { received: true }
}
\end{lstlisting}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{7cm}|}
\hline
\textbf{Event} & \textbf{Action} \\
\hline
\texttt{checkout.session.completed} & Create or update subscription with quota \\
\hline
\texttt{invoice.payment\_failed} & Log warning for monitoring \\
\hline
\end{tabular}
\caption{Handled Webhook Events}
\label{tab:webhook_events}
\end{table}

\subsection{Price Caching}

Stripe price information is cached to reduce external API calls. Figure~\ref{fig:stripe_price_caching} illustrates the caching workflow with cache penetration protection.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{images/stripe_price_caching.png}
\caption{Stripe Price Caching Workflow}
\label{fig:stripe_price_caching}
\end{figure}

The caching strategy includes:

\begin{lstlisting}[language=TypeScript, caption={Price Caching with Penetration Protection}]
private readonly CACHE_TTL = 86400  // 24 hours

async getPrice(priceId: string): Promise<Stripe.Price> {
  const cacheKey = `stripe:price:${priceId}`
  const cached = await this.redisClient.get(cacheKey)

  if (cached) {
    if (cached === 'NULL') {
      throw new Error('Price not found (cached)')
    }
    return JSON.parse(cached) as Stripe.Price
  }

  try {
    const price = await this.stripe.prices.retrieve(priceId)
    await this.redisClient.set(
      cacheKey, JSON.stringify(price), { EX: this.CACHE_TTL }
    )
    return price
  } catch (error) {
    if (error?.code === 'resource_missing') {
      await this.redisClient.set(cacheKey, 'NULL', { EX: 60 })
    }
    throw error
  }
}
\end{lstlisting}

\subsection{Subscription Lifecycle}

The module provides endpoints for managing subscription status:

\subsubsection{Cancel Subscription}

Cancellation is scheduled for the end of the current billing period:

\begin{lstlisting}[language=TypeScript, caption={Cancel Subscription}]
async cancelSubscription(subscriptionId: string) {
  return this.stripe.subscriptions.update(subscriptionId, {
    cancel_at_period_end: true,
  })
}
\end{lstlisting}

\subsubsection{Resume Subscription}

A cancelled subscription can be resumed before the period ends:

\begin{lstlisting}[language=TypeScript, caption={Resume Subscription}]
async resumeSubscription(subscriptionId: string) {
  return this.stripe.subscriptions.update(subscriptionId, {
    cancel_at_period_end: false,
  })
}
\end{lstlisting}

\subsection{Security Considerations}

\begin{itemize}
    \item \textbf{Webhook Signature Verification}: All webhooks are verified using the Stripe SDK's \texttt{constructEvent()} method with the webhook secret.
    \item \textbf{Raw Body Handling}: The webhook endpoint uses raw body parsing to preserve the payload for signature verification.
    \item \textbf{Idempotency}: The handler checks for existing subscriptions to ensure duplicate webhooks don't create duplicate records.
\end{itemize}
