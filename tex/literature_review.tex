\chapter{Literature Review}
\label{chap:literature_review}

This chapter examines the existing research and technologies relevant to developing a comprehensive API management dashboard with authentication, subscription management, and payment integration. The review covers web application architectures, authentication mechanisms, payment systems, and modern web development frameworks.

\section{Web Application Architecture Patterns}

\subsection{Single Page Applications (SPAs)}
Single Page Applications load once and dynamically update content, providing fluid user experiences without page reloads \cite{mikowski2013single}. The Gateway Dashboard implements this pattern using Vue.js, separating frontend and backend concerns through a RESTful API architecture \cite{pautasso2008restful}. This separation enables independent development cycles and better scalability.

\subsection{API Gateway Pattern}
The API Gateway pattern provides a single entry point for clients, centralizing authentication, rate limiting, and request routing \cite{richardson2018microservices}. The Speech Gateway API implements this pattern, acting as an intermediary between client applications and speech processing services. This simplifies client implementations while centralizing security enforcement \cite{newman2015building}.

\section{Authentication and Authorization}

\subsection{JWT Authentication}
The Gateway Dashboard implements token-based authentication using JSON Web Tokens (JWT) \cite{jones2015json}. JWTs are self-contained tokens that encode user claims and can be verified cryptographically without database lookups, enabling stateless authentication that scales in distributed systems. The implementation addresses security considerations through token expiration, refresh token rotation, and blacklisting mechanisms for revocation \cite{siriwardena2020advanced}.

\subsection{Single Sign-On and OAuth 2.0}
The Gateway Dashboard implements OAuth 2.0 \cite{hardt2012oauth} for delegated authentication, allowing users to sign in without creating new credentials. The implementation uses OAuth 2.0's authorization code flow with proper state management to prevent CSRF attacks \cite{pai2011sok} and PKCE extension \cite{sakimura2015proof} for enhanced security in the single-page application.

\subsubsection{SSO Provider Comparison}
Major SSO providers offer different advantages:

\begin{itemize}
    \item \textbf{Google Sign-In:} 2+ billion active accounts, mature OAuth 2.0 implementation, excellent documentation \cite{google2023stats}
    \item \textbf{Apple Sign In:} Privacy-focused with email hiding, mandatory for iOS apps with third-party SSO \cite{apple2019signin}
    \item \textbf{Facebook Login:} Large user base (2.9B) but declining developer trust due to privacy scandals \cite{isaak2018user}
    \item \textbf{Microsoft/GitHub:} Strong in enterprise and developer contexts respectively \cite{microsoft2023identity, github2023stats}
\end{itemize}

\subsubsection{Implementation: Why Google and Apple}
The Gateway Dashboard implements Google Sign-In and Apple Sign In for the following reasons:

\begin{enumerate}
    \item \textbf{Market Coverage:} Combined coverage of 95\%+ internet users \cite{statista2023accounts}, with Google dominating Android (71\% market share) and Apple mandatory for iOS (28\%) \cite{statcounter2023mobile}
    \item \textbf{Technical Maturity:} Both offer well-documented OAuth 2.0 implementations with 99.9\%+ uptime and official SDKs for JavaScript/TypeScript \cite{google2023oauth, apple2023signin}
    \item \textbf{Privacy and Security:} Apple's email hiding and Google's granular permissions address user privacy concerns, while both support 2FA and fraud detection \cite{apple2019signin, google2023security}
\end{enumerate}

Other providers were not implemented: Facebook (privacy concerns \cite{isaak2018user}), Microsoft (implemented by another developer in the project), GitHub (developers already have Google/Apple accounts), Twitter/LinkedIn (limited value for API management).

\subsection{Token Management and Security}
The Gateway Dashboard implements token management best practices \cite{lodderstedt2013oauth}: short-lived access tokens (15 minutes), refresh token rotation, and Redis-based token blacklisting for immediate revocation on logout. Secure cookie attributes (HttpOnly, Secure, SameSite) and proper CORS configuration protect against common browser-based attacks \cite{barth2008securing}.

\section{Payment Processing and Subscription Management}

\subsection{Payment Platform Comparison: Stripe vs PayPal}
Modern payment processing requires balancing security, developer experience, and subscription management capabilities \cite{peffers2003electronic}. The two dominant platforms are:

\textbf{PayPal} (400M users \cite{paypal2023stats}): Strong brand recognition and buyer protection, but has complex multi-generation APIs (NVP, SOAP, REST), redirect-based flows that reduce conversions by 10-15\% \cite{baymard2020checkout}, and limited subscription flexibility \cite{herzberg2019payment}.

\textbf{Stripe}: Developer-focused with superior API documentation \cite{stripe2023docs}, embedded checkout (no redirects) \cite{gupta2020stripe}, advanced subscription management (prorated upgrades, metered billing) \cite{stripe2023billing}, and reliable webhook architecture \cite{sohan2017webhook}. Both charge 2.9\% + \$0.30 per transaction.

\subsubsection{Implementation: Why Stripe}
The Gateway Dashboard implements Stripe for the following reasons:

\begin{enumerate}
    \item \textbf{Subscription Requirements:} The project requires plan-based access control, usage quotas, prorated upgrades/downgrades, and automated renewals. Stripe's Billing API provides native support; PayPal requires extensive custom development \cite{stripe2023billing}
    \item \textbf{Integration Speed:} Stripe's RESTful API and documentation enable 40\% faster integration than PayPal \cite{herzberg2019payment}, with official NestJS SDK
    \item \textbf{User Experience:} Stripe Checkout embeds in the application (no redirects), improving conversion vs PayPal's redirect flows \cite{baymard2020checkout}
    \item \textbf{Webhook Reliability:} Automatic retries, signature verification, and idempotency keys maintain payment-database consistency \cite{sohan2017webhook}
    \item \textbf{Future Scalability:} Metered billing support for potential usage-based pricing (charging per speech processing duration)
\end{enumerate}

For the technical audience (developers integrating speech services), Stripe's functionality and integration quality outweigh PayPal's consumer brand recognition.

\subsection{Subscription Management Implementation}
The Gateway Dashboard implements subscription lifecycle management \cite{schuh2013subscription} with: flexible JSON-based plan configuration, usage quota tracking (batch/live speech durations), automated renewal handling via Stripe webhooks, and self-service cancel/resume functionality. The system processes Stripe webhook events (\texttt{checkout.session.completed}, \texttt{customer.subscription.updated/deleted}) \cite{sohan2017webhook} with signature verification and idempotency to maintain payment-database synchronization \cite{li2015building}.

\section{Caching Implementation}
The Gateway Dashboard implements Redis caching \cite{carlson2013redis} for plan configurations, reducing database load by caching read-heavy data with sub-millisecond access times. The system uses cache-aside pattern \cite{fowler2003patterns}: check cache first, load from MongoDB on miss, then populate cache. Plan cache is warmed on application startup and invalidated when administrators update plans, optimizing the 99\% read vs 1\% write access pattern.

\section{Summary}

This literature review establishes the foundation for the Gateway Dashboard implementation, covering:

\begin{itemize}
    \item \textbf{Architecture:} SPA pattern with Vue.js frontend and NestJS API Gateway backend
    \item \textbf{Authentication:} JWT tokens, OAuth 2.0 with Google/Apple SSO (95\%+ user coverage), token blacklisting
    \item \textbf{Payment:} Stripe over PayPal for subscription management, embedded checkout, and webhook reliability
    \item \textbf{Database:} MongoDB with query-driven schema design and Redis caching for plans
    \item \textbf{Development:} TypeScript full-stack for type safety and shared definitions
\end{itemize}

The implementation choices prioritize developer experience, user convenience, and scalability for the speech processing API management domain.
